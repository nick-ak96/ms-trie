Comments to the Author

1. Is the manuscript technically sound, and do the data support the conclusions?

Reviewer #1: Partly

2. Has the statistical analysis been performed appropriately and rigorously?
Reviewer #1: N/A

3. Have the authors made all data underlying the findings in their manuscript fully available?

Reviewer #1: No

NAŠ ODZIV NA ZGORNJE:
We published the data that was used to preform experimets from the paper, and refered to those accordingly.

? (to ask Mikita, both iztok and matjaž
Matjaž takes care of publishing data)

4. Is the manuscript presented in an intelligible fashion and written in standard English?

Reviewer #1: Yes

5. Review Comments to the Author

Reviewer #1:
The motivation is not clear, the authors claim that this is an important problem in object-relational databases, information retrieval, data mining and expert systems. However, for example, when authors claim to be a relevant problem in information retrieval, they provide two citations to complete books of information retrieval, without any indication of section or chapter. Please, please be more specific. A good practice is to show the specific problems (examples) of the application.

NAŠ ODZIV NA ZGORNJE:
We followed the advice of referee, and replaced references with the more specific ones, as requested.
This can be found in the second pharagraph of the introduction (Section 1), where we overview the related areas of computer science.
Notice that in those presented areas the set containment operations play an essential role.

---

It would be nice if the authors provide running examples of their algorithms, they would be easier to understand.

NAŠ ODZIV NA ZGORNJE:
We acknowledge the remark of the reviewer, however we feel that this paper is already substentilly long, and providing an additional figure for each operation might not give the desirable outcome.

Please notice that we did include an example of the underlying multiset-trie data structure.

---

All figures are of very poor quality and can hardly be read.

NAŠ ODZIV NA ZGORNJE:
All figures presenting various plots are generated by matplotlib python library, and exported in vector format.
We believe this to be industry-standard and kindly ask for detailed explanation on how to improve their quality.
%Forthermore we believe that those figures were carefully designed

An important problem for me is that in the paper it is always assumed that the multisets are always ordered according to a certain order, more precisely, that specified in the alphabet \Sigma, or as stated on page 10, line 269 "for simplicity that all elements are ordered in an ascending order". Therefore, the authors claim that the functions search, delete and insert have complexity \sigma (the size of \Sigma). I do not agree with this, in practical implementations, for example in an object-relational database, we cannot assure that the multiset queries or insertions will have the elements in a specific order. For your method to work, a previous sort and sum are required, in order to build an instance of the type Multiset. This requires O(n log n) cost, being n the cardinality of the multiset in the query, be aware, not the distinct symbols in the multiset, all (including repeated) symbols.

NAŠ ODZIV NA ZGORNJE:

In multisets ordering is not important.
We use a specific ordering of the multiset elements to speed up the set containment queries.
This specific ordering is used when we construct the multiset-trie, so the
ordering is a part of the data structure.

We have updated the introduction (Section 1) to:
1) emphasise that the ordering is not important in multisets, and
2) to depict the utilization of the selected ordering for multiset containment operations.

---

The experiments are not convincing for the same reason, as the whole paper obviates the ordering, whereas the inverted index uses a B-tree to search for the inverted list of each element in the multiset.
The experiments must consider that the multisets are not ordered nor added, that is, an input query could be {1, 2, 2, 1, 3, 3, 1, 2, 2}


NAŠ ODZIV NA ZGORNJE:

We kindly point out that the specification of all our algorithms is designed so that the input queries are already in the so-called Multiset type (see Section 3 for more details).
This type assumes an order to the input elemens, as well as precomputed multiplicity of each of them.
We may have two distinct orderings of multisets.
The first is the application ordering where particular element can be at many places in the multiset.
The second ordering is the ordering of the symbols that is used for implementation of multiset-trie.
In particular this implies that the preprocessing step from the above comment is not covered by our complexity analysis.
We acknowledge that different applications may require the choice of our definitions to be modified.

----
The values of n, the maximum multiplicity of each element of the multiset, are small, most experiments (as shown in Table 1) are 3, and one with 10. Experiments with larger values of n are needed, and, as I will argue next, authors must include the size of the resulting data structures. The scalability must be studied, and experiments showing how the size of n affects the query times and the size of the data structure must be included.

NAŠ ODZIV:
We acknowledge that our description of the multiset-trie data structure is not optimized, as we instead strive for a clean represeantation of a new idea.
We also point out that the absence of the compression makes the multiset-trie a perfectly height-balanced tree, which simplifies the analysis.

That said, there are various ways on how to optimize this data structure further.
For example, the multiplicity of an element can be implemented using a small, customly designed, hash table (instead of a simple array as in the paper).

In fact, we added this and some other possible optimiziations to the conclusion of our paper.

-----

The idea of minimality of the data structure size stated in line 808 page 27, for me, is wrong. A simple analysis reveals that the space complexity O(|M|) is a very coarse bound, and it is not minimal. First, the size of the data structure is better bounded by the number of nodes, which is analyzed in Section 4.1.1. Second, the space efficiency is not optimal because you are using a complex method to determine the label of a node (the symbol a node contains). That is, to know the label of a node, it is necessary to know the position of the pointer that points to the node of interest, within the \sigma pointers of the parent node. Then each node needs an array of \sigma entries, even though only some of them are filled, so you are wasting many empty entries. In addition, since the label of a node is given by a pointer, unless you use a modern tree (that exists, but you have not mentioned that) I assume that you require 32 bits to represent the pointer (label) of a node. Instead, if you explicitly represent the symbol of each node, you only need log \sigma bits.

NAŠ ODZIV NA ZGORNJE:

We agree with the reviewer, and we dropped the comment about the space minimality of the data
structure in the conclusions (Section 7), accordingly.
The minimality of the data structure is not mentioned in any other part of the paper.

(Matjaž, so preostale ocene v istem odstavku o minimalnosti korektne?)

I can continue giving arguments, for example, you even recognize that your structure is based on a trie, and not on a patricia trie or compact prefix tree, that is, your structure does not support path compression, and this added to the aforementioned array of pointers at each node, yields a poor space efficiency.
Therefore, the space consumption of your data structure must be reported in the experimental section and compared with that of the inverted index.

NAŠ ODZIV NA ZGORNJE:

See the previous reply.

----

Finally, the intersection algorithm used in your experiments is not described. There are different intersection algorithms, please refer to, for example :
J. Shane Culpepper and Alistair Moffat. 2011. Efficient set intersection for inverted indexing. ACM Trans. Inf. Syst. 29, 1, Article 1 (December 2010), 25 pages. https://doi.org/10.1145/1877766.1877767

That with the better behaviour in your case must be selected.

NAŠ ODZIV NA ZGORNJE:

We understand the comment of reviewer. However, one of the authors of this paper recently went to work in industry.
As he was in charge of the development of inverted index implementation, it seems that a new implementation is hardly possible at the moment.
That said, we agree that in the current form the Experiment 5 does not fairly compare both data structures.
Accordingly, we have omitted the empirical comparison of the multiset-trie with the inverted file from the paper.

-----

Related work is poor, especially the explanation of the set-trie. Although Section 6.1 sketches the differences between multiset-trie and set-trie, more explanations are needed. First, the differences in the data structures and then, the differences in operations must be clarified.

NAŠ ODZIV NA ZGORNJE:

We have added a more detailed presentation of the set-trie in the related work.
Most notable changes can be found in the second paragraph of Section 6.1.
In the current form, also differences in operations between the two data structures are, in our opinion, exposed better (see third paragraph of Section 6.1).

Page 3 line 37 "at a certan level" -> "at a certain level"

NAŠ ODZIV NA ZGORNJE:

Corrected.
